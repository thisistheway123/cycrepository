<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Calendar | Cyc</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Calendar-specific overrides kept local */
    .past-day { background: #e0e0e0 !important; color: #aaa !important; cursor: not-allowed !important; }
  .today { background: #fff59d !important; color: #d32f2f !important; border: 2px solid #fbc02d !important; }
  /* Only apply predicted-period visuals when the cell is NOT also today */
  .predicted-period:not(.today) { background: rgba(255,200,200,0.9) !important; color: #7a0000 !important; border: 2px solid #ff8a80 !important; }
  /* Mood badge shown for predicted period days */
  .mood-badge {
    position: absolute;
    right: 6px;
    top: 6px;
    font-size: 1.05rem;
    line-height: 1;
    background: rgba(255,255,255,0.85);
    padding: 2px 6px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    pointer-events: none;
  }
  .mood-badge.low { background: rgba(235, 87, 87, 0.95); color: #fff; }
  .mood-badge.mid { background: rgba(255, 193, 7, 0.95); color: #222; }
  .mood-badge.high { background: rgba(102, 187, 106, 0.95); color: #fff; }
  /* Compact indicator for days that have notes to avoid layout warping */
  .entries { position: relative; min-height: 18px; }
  .entry-indicator {
    position: absolute;
    left: 6px;
    bottom: 6px;
    width: 10px;
    height: 10px;
    background: #ff6b6b;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }
  .entry-indicator.has-text { background: #4caf50; }
  /* Suggestions grouping styles */
  .suggestion-section { margin-bottom: 8px; }
  .suggestion-section h4 { margin: 6px 0; font-size: 0.95rem; }
  .suggestion-item { display: block; }
    table { width: 90%; max-width: 800px; margin: 0 auto; }
    th { background: purple; color: white; }
    /* Animated calendar and cells */
    .calendar-table { transform-origin: center top; border-collapse: collapse; border-spacing: 0; }
    /* show dividers on individual calendar cells */
    .calendar-table th, .calendar-table td {
      border: 1px solid rgba(0,0,0,0.12);
      padding: 10px;
      vertical-align: top;
      min-width: 86px;
      min-height: 72px;
      position: relative;
      background-clip: padding-box;
    }
    .calendar-table thead th { background: #6a1b9a; color: #fff; }
  /* Base dialog styling (moved out of inline styles so theme classes can override) */
  #eventDialog { padding: 0; border-radius: 12px; width: 420px; max-width: 92vw; height: 520px; margin: auto; position: relative; box-shadow: 0 18px 50px rgba(0,0,0,0.18); transition: background 360ms ease, color 360ms ease, transform 220ms cubic-bezier(.2,.9,.3,1); display:flex; flex-direction:column; overflow: hidden; }
  /* scrollable body inside dialog so dialog size remains fixed */
  #eventDialog .dialog-body { padding: 18px; flex: 1 1 auto; overflow: auto; }
  /* footer area remains fixed height */
  #eventDialog .dialog-footer { padding: 12px 18px; border-top: 1px solid rgba(0,0,0,0.04); display:flex; justify-content:flex-end; gap:8px; }
    /* Modal color variants to reflect the clicked day's state */
    #eventDialog.modal-default { background: #ffffff; color: #222; border-left: 6px solid rgba(0,0,0,0.06); }
    #eventDialog.modal-today { background: linear-gradient(180deg,#fffef2,#fff7c7); color: #333; border-left: 6px solid #fbc02d; }
    #eventDialog.modal-predicted { background: linear-gradient(180deg,#fff6f7,#ffecec); color: #3b0101; border-left: 6px solid #ff8a80; }
    /* make dialog content contrast-friendly */
    #eventDialog h3 { margin-top: 0; margin-bottom: 8px; }
      /* compact button variant to reuse .btn styles but smaller */
      .btn.small { padding: 6px 10px; border-radius: 8px; font-size: 0.9rem; }
      /* make suggestions area compact and scrollable to limit overall page scrolling */
      #suggestions { max-height: 36vh; overflow: auto; gap:6px; padding-right:6px; }
      /* reduce suggestion item detail size to minimize height */
      .suggestion-item div { line-height: 1.15; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes slideInFromRight { from { opacity:0; transform: translateX(18px); } to { opacity:1; transform: translateX(0);} }
    @keyframes slideOutToLeft { from { opacity:1; transform: translateX(0);} to { opacity:0; transform: translateX(-18px);} }
    @keyframes slideInFromLeft { from { opacity:0; transform: translateX(-18px); } to { opacity:1; transform: translateX(0);} }
    @keyframes slideOutToRight { from { opacity:1; transform: translateX(0);} to { opacity:0; transform: translateX(18px);} }

    .anim-in-right { animation: slideInFromRight 360ms cubic-bezier(.2,.9,.3,1) forwards; }
    .anim-out-left { animation: slideOutToLeft 320ms cubic-bezier(.2,.9,.3,1) forwards; }
    .anim-in-left { animation: slideInFromLeft 360ms cubic-bezier(.2,.9,.3,1) forwards; }
    .anim-out-right { animation: slideOutToRight 320ms cubic-bezier(.2,.9,.3,1) forwards; }

    .date-cell { opacity: 0; transform: translateY(6px); }
    @keyframes cellPop { to { opacity: 1; transform: none; } }
    .date-cell.pop { animation: cellPop 360ms cubic-bezier(.2,.9,.3,1) forwards; }

  /* Modal dialog animation */
  /* hidden by default; .open shows it */
  #eventModal { display: none; }
  #eventModal.open { display: flex; }
  #eventDialog { transform: translateY(8px) scale(0.98); opacity: 0; z-index:10001; }
  @keyframes popIn {
    0% { transform: translateY(12px) scale(0.98); opacity: 0; }
    70% { transform: translateY(-6px) scale(1.02); opacity: 1; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
  }
  @keyframes popOut {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(8px) scale(0.98); opacity: 0; }
  }
  /* helper classes to trigger animations */
  #eventDialog.animate-in { animation: popIn 320ms cubic-bezier(.2,.9,.3,1) forwards; }
  #eventDialog.animate-out { animation: popOut 220ms ease forwards; }
  /* Allow page scroll while modal is open by letting pointer-events pass through the backdrop.
    Dialog itself remains interactive. Backdrop clicks will NOT close the modal (use Cancel/Escape).
  */
  /* When hidden the modal overlay doesn't capture events; when open the overlay captures clicks so clicking backdrop can close it and prevents clicks on the calendar cells. */
  #eventModal { pointer-events: none; }
  #eventModal.open { pointer-events: auto; }
  #eventModal.open #eventDialog { pointer-events: auto; max-height: 80vh; overflow: auto; }
  </style>
</head>
<body>
  <header>
    <nav class="nav-bar">
      <div class="logo">
      <img src="cyclogo (1) (1).png" alt="  ts Logo" class="logo-img">
      </div>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="about.html">About</a>
        <a href="calendar.html">Calendar</a>
        <a href="index.html?editSurvey=1" title="Edit your menstrual survey">Edit Survey</a>
      </div>
      <div id="clock-header" style="margin-left:auto; font-size:1.3em; font-weight:bold; color:#fff; background:#333; border-radius:8px; padding:10px 30px; min-width:100px; text-align:center;"></div>
      <div class="menu-toggle">â˜°</div>
    </nav>
  </header>

  <div style="display:flex;justify-content:center;align-items:center;margin:20px 0;gap:20px;">
    <button id="prevMonthBtn">&#8592; Prev</button>
    <h2 id="calendarTitle" style="color: rgb(0, 0, 0);margin:0;"></h2>
    <button id="nextMonthBtn">Next &#8594;</button>
  </div>
  <div id="calendarContainer"></div>

  <script>
    function updateClockHeader() {
      const now = new Date();
      let h = now.getHours().toString().padStart(2, '0');
      let m = now.getMinutes().toString().padStart(2, '0');
      let s = now.getSeconds().toString().padStart(2, '0');
      document.getElementById('clock-header').textContent = `${h}:${m}:${s}`;
    }
    setInterval(updateClockHeader, 1000);
    updateClockHeader();
  </script>
  <footer>

    <div>Â© 2025 Cyc. All rights reserved.</div>
  </footer>
  <div id="eventModal" style="position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4); z-index:9999; align-items:center; justify-content:center;" aria-hidden="true" role="dialog" aria-modal="true">
    <div id="eventDialog">
      <div class="dialog-body">
      <h3 id="modalDate"></h3>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input id="eventInput" type="text" placeholder="Add custom item..." style="flex:1; padding:8px;" />
        <button id="addCustomBtn" class="btn small">Add</button>
      </div>
      <div id="itemList" style="margin-top:6px; font-size:0.95rem; color:#222; max-height:28vh; overflow:auto; padding-right:6px;">
        <!-- per-date items will appear here -->
      </div>
      <div id="suggestions" style="margin-top:12px; text-align:left; font-size:0.95rem; color:#222;">
        <!-- suggestions (foods / drinks / actions) will be injected here -->
      </div>
      </div>
      <div class="dialog-footer">
        <button id="cancelEventBtn" class="btn">Cancel</button>
        <button id="saveEventBtn" class="btn primary">Save</button>
      </div>
    </div>
  </div>
  <script>
    // Calendar logic with animated transitions
    const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
    const today = new Date();
    let viewMonth = today.getMonth();
    let viewYear = today.getFullYear();

    const calendarTitle = document.getElementById('calendarTitle');
    const calendarContainer = document.getElementById('calendarContainer');

  const modal = document.getElementById('eventModal');
  const eventDialog = document.getElementById('eventDialog');
  const eventInput = document.getElementById('eventInput');
    const saveBtn = document.getElementById('saveEventBtn');
    const cancelBtn = document.getElementById('cancelEventBtn');
    const modalDate = document.getElementById('modalDate');
    let currentEntries = null;
    let currentDate = null;
    // current modal ISO date (YYYY-MM-DD)
    let currentModalISO = null;

    // storage helpers for calendar entries
    function _loadStore() {
      try { return JSON.parse(localStorage.getItem('calendarEntries') || '{}'); } catch(e){ return {}; }
    }
    function _saveStore(s) { try { localStorage.setItem('calendarEntries', JSON.stringify(s)); } catch(e){} }
    function getItemsForISO(iso) { const s = _loadStore(); return s[iso] ? s[iso].slice() : []; }
    function setItemsForISO(iso, items) { const s = _loadStore(); s[iso] = items; _saveStore(s); }
    function addItemForISO(iso, title) { if (!title || !title.trim()) return; const items = getItemsForISO(iso); items.push({ title: title.trim(), created: Date.now() }); setItemsForISO(iso, items); return items; }
    function removeItemForISO(iso, idx) { const items = getItemsForISO(iso); if (idx < 0 || idx >= items.length) return items; items.splice(idx,1); setItemsForISO(iso, items); return items; }

    // add or remove visual indicator(s) for a given ISO date across the calendar
    function updateIndicatorForISO(iso) {
      // find all entries divs with matching dataset.iso and update their indicator
      document.querySelectorAll('.entries').forEach(container => {
        if (container.dataset && container.dataset.iso === iso) {
          const items = getItemsForISO(iso);
          let ind = container.querySelector('.entry-indicator');
          if (items && items.length > 0) {
            if (!ind) {
              ind = document.createElement('div'); ind.className = 'entry-indicator has-text'; container.appendChild(ind);
            } else {
              ind.classList.add('has-text');
            }
          } else {
            if (ind && ind.parentNode) ind.parentNode.removeChild(ind);
          }
        }
      });
    }

    // render modal's item list (with delete buttons)
    function renderModalItemList(items) {
      const container = document.getElementById('itemList');
      container.innerHTML = '';
      if (!items || items.length === 0) {
        const empty = document.createElement('div'); empty.style.color = '#666'; empty.textContent = 'No items yet'; container.appendChild(empty); return;
      }
      items.forEach((it, i) => {
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.justifyContent = 'space-between'; row.style.alignItems = 'center'; row.style.padding = '6px 4px'; row.style.borderBottom = '1px solid rgba(0,0,0,0.04)';
        const left = document.createElement('div'); left.textContent = it.title; left.style.textAlign = 'left'; left.style.flex = '1'; left.style.paddingRight = '8px';
        const del = document.createElement('button'); del.className = 'btn small'; del.textContent = 'Delete'; del.addEventListener('click', () => {
          const updated = removeItemForISO(currentModalISO, i);
          renderModalItemList(updated);
          // update indicator on calendar cell(s)
          updateIndicatorForISO(currentModalISO);
          // re-render suggestions so the removed title becomes available again
          try {
            const entriesDiv = document.querySelector(`.entries[data-iso="${currentModalISO}"]`);
            const isPred = entriesDiv && entriesDiv.parentNode && entriesDiv.parentNode.classList.contains('predicted-period');
            renderSuggestions(new Date(currentModalISO), isPred);
          } catch(e){}
        });
        row.appendChild(left); row.appendChild(del); container.appendChild(row);
      });
    }

    // add custom button wiring
    document.getElementById('addCustomBtn').addEventListener('click', () => {
      if (!currentModalISO) return;
      const val = (eventInput.value || '').trim();
      if (!val) return;
      const updated = addItemForISO(currentModalISO, val);
      renderModalItemList(updated);
      eventInput.value = '';
      updateIndicatorForISO(currentModalISO);
      // re-render suggestions to hide any suggestion with the same title
      try {
        const entriesDiv = document.querySelector(`.entries[data-iso="${currentModalISO}"]`);
        const isPred = entriesDiv && entriesDiv.parentNode && entriesDiv.parentNode.classList.contains('predicted-period');
        renderSuggestions(new Date(currentModalISO), isPred);
      } catch(e){}
    });

    // build a table element for the given month/year (doesn't attach)
    function buildCalendar(month, year) {
      calendarTitle.textContent = `${monthNames[month]} ${year}`;
      const firstDay = new Date(year, month, 1).getDay();
      const daysInMonth = new Date(year, month + 1, 0).getDate();

      // Load menstrual data (if any) from localStorage
      let menstrualData = null;
      try { menstrualData = JSON.parse(localStorage.getItem('menstrualData') || 'null'); } catch(e) { menstrualData = null; }
      const msPerDay = 24*60*60*1000;
      function isPredictedPeriod(dateObj) {
        if (!menstrualData || !menstrualData.lastStart) return false;
        const cycle = parseInt(menstrualData.cycleLength,10) || 28;
        const period = parseInt(menstrualData.periodLength,10) || 5;
        const last = new Date(menstrualData.lastStart + 'T00:00:00');
        const diff = Math.floor((dateObj - last) / msPerDay);
        const mod = ((diff % cycle) + cycle) % cycle;
        return mod >= 0 && mod < period;
      }

      const table = document.createElement('table');
  table.className = 'calendar-table';
  table.setAttribute('bgcolor','lightgrey');
  // reduce default cell spacing so CSS borders are visible
  table.setAttribute('cellspacing','0');
  table.setAttribute('cellpadding','0');

      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(d => { const th = document.createElement('th'); th.textContent = d; headRow.appendChild(th); });
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      let date = 1;
      let seq = 0; // for staggering
      for (let i = 0; i < 6; i++) {
        const row = document.createElement('tr');
        for (let j = 0; j < 7; j++) {
          const cell = document.createElement('td');
          if (i === 0 && j < firstDay) {
            // empty cell
          } else if (date > daysInMonth) {
            // empty
          } else {
            const dateDiv = document.createElement('div');
            dateDiv.className = 'date-number';
            dateDiv.textContent = date;
            const entriesDiv = document.createElement('div');
            entriesDiv.className = 'entries';
            cell.appendChild(dateDiv);
            cell.appendChild(entriesDiv);

            // mark predicted period and show mood indicator
            const cellDateObj = new Date(year, month, date);
            // compute period index (day in cycle) and period length if available
            let dayIndex = null;
            let periodLen = null;
            if (menstrualData && menstrualData.lastStart) {
              const cycle = parseInt(menstrualData.cycleLength,10) || 28;
              const period = parseInt(menstrualData.periodLength,10) || 5;
              const last = new Date(menstrualData.lastStart + 'T00:00:00');
              const diff = Math.floor((cellDateObj - last) / msPerDay);
              const mod = ((diff % cycle) + cycle) % cycle;
              if (mod >= 0 && mod < period) {
                dayIndex = mod; periodLen = period;
                cell.classList.add('predicted-period');
              }
            }
            // If this day is within predicted period, add a small mood badge
            if (dayIndex !== null) {
              // map dayIndex -> mood strength
              const pos = (periodLen && periodLen > 1) ? (dayIndex / (periodLen - 1)) : 0;
              // simple heuristic: earlier days tend toward lower mood, later days gradually improve
              // compute a score from 1..-1 where 1 is best mood, -1 worst
              const score = 1 - 2 * pos; // 1 -> -1 across the span
              let emoji = 'ðŸ˜';
              let cls = 'mid';
              let label = 'Neutral mood expected';
              if (score >= 0.5) { emoji = 'ðŸ™‚'; cls = 'high'; label = 'Positive/relieved'; }
              else if (score >= 0.05) { emoji = 'ðŸ˜Œ'; cls = 'mid'; label = 'Okay/steady'; }
              else if (score >= -0.25) { emoji = 'ðŸ˜•'; cls = 'mid'; label = 'Low energy'; }
              else { emoji = 'ðŸ˜¢'; cls = 'low'; label = 'Low mood likely'; }
              const badge = document.createElement('div');
              badge.className = `mood-badge ${cls}`;
              badge.textContent = emoji;
              badge.title = `Predicted period day ${dayIndex + 1}/${periodLen}: ${label}`;
              cell.appendChild(badge);
            }

            // attach ISO identifier and restore compact indicator if there are stored items for this date
            const thisISO = cellDateObj.toISOString().slice(0,10);
            entriesDiv.dataset.iso = thisISO;
            (function(iso, container){
              const items = getItemsForISO(iso);
              if (items && items.length > 0) {
                const ind = document.createElement('div');
                ind.className = 'entry-indicator has-text';
                container.appendChild(ind);
              }
            })(thisISO, entriesDiv);
            // mark past/today
            if (year < today.getFullYear() || (year === today.getFullYear() && month < today.getMonth()) || (year === today.getFullYear() && month === today.getMonth() && date < today.getDate())) {
              cell.classList.add('past-day');
            } else if (year === today.getFullYear() && month === today.getMonth() && date === today.getDate()) {
              cell.classList.add('today');
            }

            // animation: staggered pop using rAF to avoid piling up timers
            cell.classList.add('date-cell');
            // small stagger based on sequence
            cell.style.animationDelay = `${seq * 32}ms`;
            // use rAF chain to schedule pop without many timeouts
            (function(c, s){
              requestAnimationFrame(() => {
                // next frame allow computed style to settle then add pop
                requestAnimationFrame(() => c.classList.add('pop'));
              });
            })(cell, seq);
            seq++;

            date++;
          }
          row.appendChild(cell);
        }
        tbody.appendChild(row);
        if (date > daysInMonth) break;
      }

      table.appendChild(tbody);

      // Attach click listeners for each date cell
      table.querySelectorAll('td').forEach(cell => {
        const dateNumber = cell.querySelector('.date-number');
        if (!dateNumber) return;
        cell.addEventListener('click', () => {
          if (modal.classList.contains('open')) return; // ignore clicks while modal is open
          console.log('calendar cell clicked:', dateNumber.textContent, month, year);
          if (cell.classList.contains('past-day')) return;
          const entries = cell.querySelector('.entries');
            if (dateNumber && entries) {
            currentEntries = entries;
            currentDate = dateNumber.textContent;
            // compute ISO and set current modal date
            const iso = new Date(year, month, Number(currentDate)).toISOString().slice(0,10);
            currentModalISO = iso;
            modal.dataset.date = iso;
            // render stored items into modal list
            const items = getItemsForISO(iso);
            renderModalItemList(items);
            // render contextual suggestions for this date (foods/drinks/actions)
            const dateObj = new Date(year, month, Number(currentDate));
            try { renderSuggestions(dateObj, cell.classList.contains('predicted-period')); } catch(e){ console.warn('renderSuggestions failed', e); }
            modalDate.textContent = `Event for ${monthNames[month]} ${currentDate}, ${year}`;
            // set modal visual according to cell state
            eventDialog.classList.remove('modal-default','modal-today','modal-predicted');
            if (cell.classList.contains('today')) eventDialog.classList.add('modal-today');
            else if (cell.classList.contains('predicted-period')) eventDialog.classList.add('modal-predicted');
            else eventDialog.classList.add('modal-default');
            // show modal with animation
            showModal();
          }
        });
      });

      return table;
    }

    // Swap current calendar with new one using directional animation
    function showCalendar(month, year, dir) {
      const newTable = buildCalendar(month, year);
      // dir: -1 = left (previous), +1 = right (next), 0 = none
      if (!calendarContainer.firstElementChild) {
        // initial
        calendarContainer.appendChild(newTable);
        return;
      }
      const old = calendarContainer.firstElementChild;
      if (dir === 1) {
        newTable.classList.add('anim-in-right');
        old.classList.add('anim-out-left');
        calendarContainer.appendChild(newTable);
      } else if (dir === -1) {
        newTable.classList.add('anim-in-left');
        old.classList.add('anim-out-right');
        calendarContainer.appendChild(newTable);
      } else {
        // no directional animation - simple replace with fadeInUp
        newTable.style.animation = 'fadeInUp 300ms ease forwards';
        calendarContainer.appendChild(newTable);
        old.remove();
        return;
      }

      // remove old after its animation ends
      old.addEventListener('animationend', () => {
        if (old && old.parentNode) old.parentNode.removeChild(old);
      }, { once: true });
    }

    let previousFocus = null;
    function showModal() {
      console.log('showModal called');
      previousFocus = document.activeElement;
  modal.classList.add('open');
  modal.setAttribute('aria-hidden','false');
  // do not disable body scrolling; keep overlay pointer-events none so background scroll works
  modal.style.zIndex = 99999;
      // ensure no leftover classes
      eventDialog.classList.remove('animate-out');
      // animate in
      eventDialog.classList.add('animate-in');
      // focus when animation finishes
      eventDialog.addEventListener('animationend', function onEnd() {
        eventDialog.removeEventListener('animationend', onEnd);
        try { eventInput.focus(); } catch(e){}
      });
    }

    function hideModal() {
  modal.setAttribute('aria-hidden','true');
      // animate out
      eventDialog.classList.remove('animate-in');
      eventDialog.classList.add('animate-out');
      eventDialog.addEventListener('animationend', function onClose() {
        eventDialog.removeEventListener('animationend', onClose);
  modal.classList.remove('open');
  try { if (previousFocus && previousFocus.focus) previousFocus.focus(); } catch(e){}
      });
    }

    // close modal on Escape for robustness
    document.addEventListener('keydown', (ev) => {
      if (ev.key === 'Escape' && modal.classList.contains('open')) {
        hideModal();
      }
    });

    document.getElementById('prevMonthBtn').addEventListener('click', () => {
      viewMonth--;
      if (viewMonth < 0) { viewMonth = 11; viewYear--; }
      showCalendar(viewMonth, viewYear, -1);
    });
    document.getElementById('nextMonthBtn').addEventListener('click', () => {
      viewMonth++;
      if (viewMonth > 11) { viewMonth = 0; viewYear++; }
      showCalendar(viewMonth, viewYear, 1);
    });

    saveBtn.addEventListener('click', () => {
      // just close modal; items are saved immediately on add/delete
      hideModal();
    });
    cancelBtn.addEventListener('click', () => { hideModal(); });
    // compute suggestions for a date: foods, drinks, and actions including pain-relief.
    function computeSuggestionsForDate(dateObj, isPredictedPeriod) {
      // Basic contextual rules â€“ can be extended or replaced with richer data.
      const suggestions = [];
      // general comfort foods
      suggestions.push({ type: 'food', title: 'Warm soup', details: 'Easy on the stomach, comforting and hydrating.' });
      suggestions.push({ type: 'food', title: 'Bananas', details: 'High in potassium and gentle on digestion.' });
      suggestions.push({ type: 'drink', title: 'Ginger tea', details: 'Helps with nausea and cramping.' });
      suggestions.push({ type: 'drink', title: 'Warm water with lemon', details: 'Hydrating and soothing.' });
      suggestions.push({ type: 'action', title: 'Gentle stretching', details: 'Light movement can ease cramps and improve mood.' });
      suggestions.push({ type: 'action', title: 'Heat pack', details: 'Apply to lower abdomen for 15â€“20 minutes for pain relief.' });
      suggestions.push({ type: 'action', title: 'Rest and nap', details: 'Short rests often help energy and mood.' });
      // If predicted period, prioritize pain-relief and magnesium-rich foods
      if (isPredictedPeriod) {
        suggestions.unshift({ type: 'action', title: 'Pain reliever (if appropriate)', details: 'Ibuprofen or acetaminophen can help â€” follow dosing instructions.' });
        suggestions.unshift({ type: 'food', title: 'Dark chocolate (small)', details: 'May improve mood and contains magnesium.' });
        suggestions.push({ type: 'food', title: 'Yogurt', details: 'Protein and probiotics; gentle choice.' });
      }
      // simple day-of-week variations (weekend = indulgence; weekday = lighter)
      const dow = dateObj.getDay();
      if (dow === 0 || dow === 6) { // weekend
        suggestions.push({ type: 'food', title: 'Comfort brunch', details: 'Pancakes, eggs, or your favorite leisurely meal.' });
      } else {
        suggestions.push({ type: 'food', title: 'Simple salad or wrap', details: 'Quick, light, and energizing.' });
      }
      return suggestions;
    }

    function renderSuggestions(dateObj, isPredictedPeriod) {
      const container = document.getElementById('suggestions');
      if (!container) return;
      const list = computeSuggestionsForDate(dateObj, !!isPredictedPeriod);
      // filter out suggestions that are already added for this date
      const iso = dateObj.toISOString().slice(0,10);
      const existing = getItemsForISO(iso).map(i => i.title);
      container.innerHTML = '';
      const header = document.createElement('div');
      header.style.fontWeight = '600';
      header.style.marginBottom = '8px';
      header.textContent = isPredictedPeriod ? 'Suggested for predicted period days' : 'Suggestions';
      container.appendChild(header);

      // group by type
  const foods = list.filter(i => (i.type === 'food' || i.type === 'drink') && !existing.includes(i.title));
  const remedies = list.filter(i => i.type === 'action' && !existing.includes(i.title));

      function renderSection(titleText, items) {
        if (!items || items.length === 0) return;
        const sec = document.createElement('div');
        sec.className = 'suggestion-section';
        const h = document.createElement('h4');
        h.textContent = titleText;
        sec.appendChild(h);
        items.forEach(item => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'suggestion-item';
          itemDiv.style.padding = '8px 6px';
          itemDiv.style.borderRadius = '6px';
          itemDiv.style.marginBottom = '6px';
          itemDiv.style.background = 'rgba(250,250,250,0.9)';
          itemDiv.style.border = '1px solid #eee';
          const title = document.createElement('div');
          title.textContent = item.title;
          title.style.fontWeight = '600';
          const details = document.createElement('div');
          details.textContent = item.details;
          details.style.fontSize = '0.9rem';
          details.style.color = '#444';
          details.style.marginTop = '4px';
          const addBtn = document.createElement('button');
          addBtn.textContent = 'Add';
          addBtn.className = 'btn small';
          addBtn.style.float = 'right';
          addBtn.style.marginLeft = '8px';
          addBtn.addEventListener('click', () => {
            // Persist the suggestion as an item for the current modal date
            if (!currentModalISO) return;
            const updated = addItemForISO(currentModalISO, item.title);
            renderModalItemList(updated);
            updateIndicatorForISO(currentModalISO);
            // re-render suggestions for this date to remove the added item
            try {
              const entriesDiv = document.querySelector(`.entries[data-iso="${currentModalISO}"]`);
              const isPred = entriesDiv && entriesDiv.parentNode && entriesDiv.parentNode.classList.contains('predicted-period');
              renderSuggestions(new Date(currentModalISO), isPred);
            } catch(e){}
          });
          itemDiv.appendChild(addBtn);
          itemDiv.appendChild(title);
          itemDiv.appendChild(details);
          sec.appendChild(itemDiv);
        });
        container.appendChild(sec);
      }

      renderSection('Foods & Drinks', foods);
      renderSection('Remedies & Actions', remedies);
    }

    modal.addEventListener('click', e => { if (e.target === modal) hideModal(); });

    // initial render
    showCalendar(viewMonth, viewYear, 0);
  </script>
  <script src="script.js"></script>

</body>
</html>